diff -r 16a4000624a7 stomp/connect.py
--- a/stomp/connect.py	Sun May 02 18:15:34 2010 +0100
+++ b/stomp/connect.py	Mon Jun 06 16:58:22 2011 +0100
@@ -22,7 +22,7 @@
     ssl = None
     class SSLError:
         pass
-    
+
 import exception
 import listener
 import utils
@@ -33,7 +33,7 @@
 try:
     logging.config.fileConfig('stomp.log.conf')
 except:
-    pass      
+    pass
 log = logging.getLogger('stomp.py')
 if not log:
     log = utils.DevNullLogger()
@@ -51,30 +51,30 @@
     # and external interfaces).  This is used for determining
     # preferred targets.
     __localhost_names = [ "localhost", "127.0.0.1" ]
-    
+
     try:
         __localhost_names.append(socket.gethostbyname(socket.gethostname()))
     except:
         pass
-        
+
     try:
         __localhost_names.append(socket.gethostname())
     except:
         pass
-        
+
     try:
         __localhost_names.append(socket.getfqdn(socket.gethostname()))
     except:
         pass
-    
+
     #
     # Used to parse the STOMP "content-length" header lines,
     #
     __content_length_re = re.compile('^content-length[:]\\s*(?P<value>[0-9]+)', re.MULTILINE)
-    
 
-    def __init__(self, 
-                 host_and_ports = [ ('localhost', 61613) ], 
+
+    def __init__(self,
+                 host_and_ports = [ ('localhost', 61613) ],
                  user = None,
                  passcode = None,
                  prefer_localhost = True,
@@ -88,28 +88,31 @@
                  ssl_key_file = None,
                  ssl_cert_file = None,
                  ssl_ca_certs = None,
-                 ssl_cert_validator = None):
+                 ssl_cert_validator = None,
+                 version = None,
+                 heartbeat = None,
+                 virtual_host = None):
         """
         Initialize and start this connection.
 
-        \param host_and_ports            
+        \param host_and_ports
             a list of (host, port) tuples.
 
         \param prefer_localhost
             if True and the local host is mentioned in the (host,
             port) tuples, try to connect to this first
 
-        \param try_loopback_connect    
+        \param try_loopback_connect
             if True and the local host is found in the host
             tuples, try connecting to it using loopback interface
             (127.0.0.1)
 
-        \param reconnect_sleep_initial 
+        \param reconnect_sleep_initial
             initial delay in seconds to wait before reattempting
             to establish a connection if connection to any of the
             hosts fails.
 
-        \param reconnect_sleep_increase 
+        \param reconnect_sleep_increase
             factor by which the sleep delay is increased after
             each connection attempt. For example, 0.5 means
             to wait 50% longer than before the previous attempt,
@@ -127,18 +130,18 @@
             stampeding. For example, a value of 0.1 means to wait
             an extra 0%-10% (randomly determined) of the delay
             calculated using the previous three parameters.
-                 
+
         \param reconnect_attempts_max
             maximum attempts to reconnect
-                
+
         \param use_ssl
-            connect using SSL to the socket.  This wraps the 
-            socket in a SSL connection.  The constructor will 
+            connect using SSL to the socket.  This wraps the
+            socket in a SSL connection.  The constructor will
             raise an exception if you ask for SSL, but it can't
             find the SSL module.
 
         \param ssl_cert_file
-            the path to a X509 certificate 
+            the path to a X509 certificate
 
         \param ssl_key_file
             the path to a X509 key file
@@ -146,7 +149,7 @@
         \param ssl_ca_certs
             the path to the a file containing CA certificates
             to validate the server against.  If this is not set,
-            server side certificate validation is not done. 
+            server side certificate validation is not done.
 
         \param ssl_cert_validator
             function which performs extra validation on the client
@@ -159,6 +162,16 @@
 
             where OK is a boolean, and cert is a certificate structure
             as returned by ssl.SSLSocket.getpeercert()
+
+        \param version
+            (optional) stomp version header to send (comma separated)
+
+        \param heartbeat
+            (optional) heartbeat header to send (STOMP 1.1)
+
+        \param virtual_host
+            (optional) virtual_host header to send (STOMP 1.1)
+
         """
 
         sorted_host_and_ports = []
@@ -179,7 +192,7 @@
             for host_and_port in sorted_host_and_ports:
                 if self.is_localhost(host_and_port) == 1:
                     port = host_and_port[1]
-                    if (not ("127.0.0.1", port) in sorted_host_and_ports 
+                    if (not ("127.0.0.1", port) in sorted_host_and_ports
                         and not ("localhost", port) in sorted_host_and_ports):
                         loopback_host_and_ports.append(("127.0.0.1", port))
 
@@ -199,21 +212,30 @@
         self.__reconnect_sleep_jitter = reconnect_sleep_jitter
         self.__reconnect_sleep_max = reconnect_sleep_max
         self.__reconnect_attempts_max = reconnect_attempts_max
-        
+
         self.__connect_headers = {}
         if user is not None and passcode is not None:
             self.__connect_headers['login'] = user
             self.__connect_headers['passcode'] = passcode
 
+        if version is not None:
+            self.__connect_headers['accept-version'] = version
+
+        if heartbeat is not None:
+            self.__connect_headers['heart-beat'] = heartbeat
+
+        if virtual_host is not None:
+            self.__connect_headers['host'] = virtual_host
+
         self.__socket = None
         self.__socket_semaphore = threading.BoundedSemaphore(1)
         self.__current_host_and_port = None
 
         self.__receiver_thread_exit_condition = threading.Condition()
         self.__receiver_thread_exited = False
-        
+
         self.blocking = None
-        
+
         if use_ssl and not ssl:
             raise Exception("SSL connection requested, but SSL library not found.")
         self.__ssl = use_ssl
@@ -267,7 +289,7 @@
         connection.
         """
         return self.__current_host_and_port
-        
+
     def is_connected(self):
         """
         Return true if the socket managed by this connection is connected
@@ -276,7 +298,7 @@
             return self.__socket is not None and self.__socket.getsockname()[1] != 0
         except socket.error:
             return False
-        
+
     #
     # Manage objects listening to incoming frames
     #
@@ -284,18 +306,18 @@
     def set_listener(self, name, listener):
         """
         Set a named listener on this connection
-        
+
         \see listener::ConnectionListener
-        
+
         \param name the name of the listener
         \param listener the listener object
         """
         self.__listeners[name] = listener
-        
+
     def remove_listener(self, name):
         """
         Remove a listener according to the specified name
-        
+
         \param name the name of the listener to remove
         """
         del self.__listeners[name]
@@ -303,7 +325,7 @@
     def get_listener(self, name):
         """
         Return a named listener
-        
+
         \param name the listener to return
         """
         if name in self.__listeners:
@@ -326,7 +348,7 @@
         Send an UNSUBSCRIBE frame to unsubscribe from a queue
         """
         self.__send_frame_helper('UNSUBSCRIBE', '', utils.merge_headers([headers, keyword_headers]), [ ('destination', 'id') ])
-        
+
     def send(self, message='', headers={}, **keyword_headers):
         """
         Send a message (SEND) frame
@@ -335,23 +357,23 @@
             content_length_headers = {'content-length': len(message)}
         else:
             content_length_headers = {}
-        self.__send_frame_helper('SEND', message, utils.merge_headers([headers, 
+        self.__send_frame_helper('SEND', message, utils.merge_headers([headers,
                                                                         keyword_headers,
                                                                         content_length_headers]), [ 'destination' ])
         self.__notify('send', headers, message)
-    
+
     def ack(self, headers={}, **keyword_headers):
         """
         Send an ACK frame, to acknowledge receipt of a message
         """
         self.__send_frame_helper('ACK', '', utils.merge_headers([headers, keyword_headers]), [ 'message-id' ])
-        
+
     def begin(self, headers={}, **keyword_headers):
         """
         Send a BEGIN frame to start a transaction
         """
         use_headers = utils.merge_headers([headers, keyword_headers])
-        if not 'transaction' in use_headers.keys(): 
+        if not 'transaction' in use_headers.keys():
             use_headers['transaction'] = str(uuid.uuid4())
         self.__send_frame_helper('BEGIN', '', use_headers, [ 'transaction' ])
         return use_headers['transaction']
@@ -361,7 +383,7 @@
         Send an ABORT frame to rollback a transaction
         """
         self.__send_frame_helper('ABORT', '', utils.merge_headers([headers, keyword_headers]), [ 'transaction' ])
-        
+
     def commit(self, headers={}, **keyword_headers):
         """
         Send a COMMIT frame to commit a transaction (send pending messages)
@@ -376,12 +398,15 @@
             while not self.is_connected(): time.sleep(0.1)
             del keyword_headers['wait']
         self.__send_frame_helper('CONNECT', '', utils.merge_headers([self.__connect_headers, headers, keyword_headers]), [ ])
-        
+
     def disconnect(self, headers={}, **keyword_headers):
         """
         Send a DISCONNECT frame to finish a connection
         """
         self.__send_frame_helper('DISCONNECT', '', utils.merge_headers([self.__connect_headers, headers, keyword_headers]), [ ])
+        self.close_socket()
+
+    def close_socket(self):
         self.__running = False
         if self.__socket is not None:
             if self.__ssl:
@@ -449,20 +474,23 @@
                 raise KeyError("Command %s requires header %r" % (command, required_header_key))
         self.__send_frame(command, headers, payload)
 
+    def send_frame(self, command, headers={}, payload=''):
+        self.__send_frame(command, headers, payload)
+
     def __send_frame(self, command, headers={}, payload=''):
         """
         Send a STOMP frame.
-        
+
         \param command the frame command
-        
+
         \param headers a map of headers (key-val pairs)
-        
+
         \param payload the message payload
         """
         if type(payload) == dict:
             headers["transformation"] = "jms-map-xml"
-            payload = self.__convert_dict(payload)        
-        
+            payload = self.__convert_dict(payload)
+
         if self.__socket is not None:
             try:
                 frame = [ command + '\n' ]
@@ -488,11 +516,11 @@
     def __notify(self, frame_type, headers=None, body=None):
         """
         Utility function for notifying listeners of incoming and outgoing messages
-        
+
         \param frame_type the type of message
-        
+
         \param headers the map of headers associated with the message
-        
+
         \param body the content of the message
         """
         for listener in self.__listeners.values():
@@ -529,10 +557,10 @@
                     try:
                         try:
                             self.__notify('connecting')
-                            
+
                             while self.__running:
                                 frames = self.__read()
-                                
+
                                 for frame in frames:
                                     (frame_type, headers, body) = utils.parse_frame(frame)
                                     log.debug("Received frame: result=%r, headers=%r, body=%r" % (frame_type, headers, body))
@@ -586,9 +614,9 @@
             if '\x00' in c:
                 break
         self.__recvbuf += fastbuf.getvalue()
-        fastbuf.close() 
+        fastbuf.close()
         result = []
-        
+
         if len(self.__recvbuf) > 0 and self.__running:
             while True:
                 pos = self.__recvbuf.find('\x00')
@@ -619,7 +647,7 @@
                 else:
                     break
         return result
-    
+
     def __attempt_connection(self):
         """
         Try connecting to the (host, port) tuples specified at construction time.
@@ -637,17 +665,17 @@
                         else:
                             cert_validation = ssl.CERT_NONE
                         self.__socket = ssl.wrap_socket(self.__socket, keyfile = self.__ssl_key_file,
-                                certfile = self.__ssl_cert_file, cert_reqs = cert_validation, 
+                                certfile = self.__ssl_cert_file, cert_reqs = cert_validation,
                                 ca_certs=self.__ssl_ca_certs, ssl_version = ssl.PROTOCOL_SSLv3)
                     self.__socket.settimeout(None)
                     if self.blocking is not None:
                         self.__socket.setblocking(self.blocking)
                     self.__socket.connect(host_and_port)
-                    
+
                     #
                     # Validate server cert
                     #
-                    if self.__ssl and self.__ssl_cert_validator: 
+                    if self.__ssl and self.__ssl_cert_validator:
                         cert = self.__socket.getpeercert()
                         (ok, errmsg) = apply(self.__ssl_cert_validator, (cert, host_and_port[0]))
                         if not ok:
@@ -667,8 +695,8 @@
                     log.warning("Could not connect to host %s, port %s: %s" % (host_and_port[0], host_and_port[1], exc))
 
             if self.__socket is None:
-                sleep_duration = (min(self.__reconnect_sleep_max, 
-                                      ((self.__reconnect_sleep_initial / (1.0 + self.__reconnect_sleep_increase)) 
+                sleep_duration = (min(self.__reconnect_sleep_max,
+                                      ((self.__reconnect_sleep_initial / (1.0 + self.__reconnect_sleep_increase))
                                        * math.pow(1.0 + self.__reconnect_sleep_increase, sleep_exp)))
                                   * (1.0 + random.random() * self.__reconnect_sleep_jitter))
                 sleep_end = time.time() + sleep_duration
@@ -680,4 +708,4 @@
                     sleep_exp += 1
 
         if not self.__socket:
-            raise exception.ReconnectFailedException
\ No newline at end of file
+            raise exception.ReconnectFailedException
